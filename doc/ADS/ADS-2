===============================================================================
= ADS-2, rev: 0.1: Atrinik Protocol Specification                             =
===============================================================================
 This document contains design specification for the Atrinik client<->server
 protocol. The following sections exist:

 1. Session
    1.2 Keepalive
 2. Server commands
    1.2.1  Server command CONTROL
    1.2.2  Server command ASK_FACE
    1.2.3  Server command SETUP
    1.2.4  Server command VERSION
    1.2.5  Server command REQUEST_FILE
    1.2.6  Server command CLEAR
    1.2.7  Server command REQUEST_UPDATE
    1.2.8  Server command KEEPALIVE
    1.2.9  Server command ACCOUNT
    1.2.10 Server command ITEM_EXAMINE
    1.2.11 Server command ITEM_APPLY
    1.2.12 Server command ITEM_MOVE
    1.2.13 Server command REPLY
    1.2.14 Server command PLAYER_CMD
    1.2.15 Server command ITEM_LOCK
    1.2.16 Server command ITEM_MARK
    1.2.17 Server command FIRE
    1.2.18 Server command QUICKSLOT
    1.2.19 Server command QUESTLIST
    1.2.20 Server command MOVE_PATH
    1.2.21 Server command ITEM_READY
    1.2.22 Server command TALK
    1.2.23 Server command MOVE
    1.2.24 Server command TARGET
 3. Client commands
    1.3.1  Client command MAP
    1.3.2  Client command DRAWINFO
    1.3.3  Client command FILE_UPDATE
    1.3.4  Client command ITEM
    1.3.5  Client command SOUND
    1.3.6  Client command TARGET
    1.3.7  Client command ITEM_UPDATE
    1.3.8  Client command ITEM_DELETE
    1.3.9  Client command STATS
    1.3.10 Client command IMAGE
    1.3.11 Client command ANIM
    1.3.12 Client command SKILL_READY
    1.3.13 Client command PLAYER
    1.3.14 Client command MAPSTATS
    1.3.15 Client command SKILL_LIST
    1.3.16 Client command VERSION
    1.3.17 Client command SETUP
    1.3.18 Client command CONTROL
    1.3.19 Client command DATA
    1.3.20 Client command CHARACTERS
    1.3.21 Client command BOOK
    1.3.22 Client command PARTY
    1.3.23 Client command QUICKSLOT
    1.3.24 Client command COMPRESSED
    1.3.25 Client command REGION_MAP
    1.3.26 Client command SOUND_AMBIENT
    1.3.27 Client command INTERFACE
    1.3.28 Client command NOTIFICATION
 4. Example logic

===============================================================================
= 1. Session                                                                  =
===============================================================================
 Atrinik uses a standard TCP/IP connection to establish a session. Once a
 session has been established, the client and the server are free to exchange
 data at will, in an asynchronous mode of data exchange. After this is done, it
 is recommended that the server and the client exchange version information,
 with the use of the version command (see section 1.2.4 and section 1.3.16).
 This allows both the client and the server to be aware of what commands the
 other side supports, and in what format, thus allowing backward compatibility.

 Currently, only IPv4 sessions are supported, but IPv6 support is planned but
 not yet implemented in any way whatsoever.

 The network order is MSB (Most Significant Byte), also known as big-endian.

 The implementation SHOULD use non-blocking sockets to receive and send data.
 Using threads for this is highly recommended.

 The implementation SHOULD disable Nagle's algorithm, as this algorithm is
 enabled by default but introduces artificial lag due to buffering data until
 some amount of data has been buffered, then flushing the buffer. This
 behaviour has no place in a real-time action RPG such as Atrinik, where player
 should get feedback to their actions as quickly as possible.

 The server implementation MUST use some sort of buffers for data to send and
 receive, in order to allow for cancellation/compression/prioritisation/etc.
 The recommended approach is to use FIFO queues. The client is free to choose
 whether to implement such behaviour.

===============================================================================
= 1.1. Packets                                                                =
===============================================================================
 Data packets are constructed in MSB (Most Significant Byte) order, also known
 as big-endian.

 Each packet starts with a 2-byte header, which is an integer that contains
 information about the length of its payload. In the case of the client, this
 should always be sent to the server as unsigned (uint16).

 The server MUST implement the following additional behaviour for the header:
 in the case that the payload length is longer than 32767 (size of sint16), it
 MUST extend the header length to 3 bytes, thus changing the length to a 24-bit
 unsigned integer. The value of "128" MUST be ORed to the first byte. The
 client MUST add logic to handle this: if the first 8-bit integer can be ANDed
 with 128, then the header size is 3 bytes instead of 2. Standard left-shifting
 applies for both header sizes, but if the header size is 3, the first byte
 MUST be ANDed with 127 before shifting.

 The payload should always contain the command type as 8-bit integer, followed
 by any data, in any format whatsoever, but still binary. See section 1.2. for
 the available server commands organized by command type, and section 1.3. for
 the available client commands.

 Left shifting is done to convert any integers of size more than 1 byte. Signed
 integers are converted to signed data type.

 The following packet data types are recognised:
  - uint8
  - sint8
  - uint16
  - sint16
  - uint32
  - sint32
  - uint64
  - sint64
  - float:
     Multiplied by 100000, then sent as uint32. Parsed as uint32, then divided
     by 100000 to get the floating point number.
  - string:
     ASCII string, terminated by a NUL character.

===============================================================================
= 1.2. Keepalive                                                              =
===============================================================================
 Once a session has been established, the client MUST send keepalive (command
 explained in section 3.8) packets to the server, at an interval of no more
 than one packet per minute.

 If the server does not receive a keepalive packet from the client for a period
 longer than 10 minutes, it MUST, for all intents and purposes, consider the
 session as dead and drop connection immediately.

===============================================================================
= 1.2. Server commands                                                        =
===============================================================================
 The following is a list of commands recognised by the server.

 These start at zero; thus, command type 0 equals that of the first command
 here.

 CONTROL:
  See section 1.2.1.
 ASK_FACE:
  See section 1.2.2.
 SETUP:
  See section 1.2.3.
 VERSION:
  See section 1.2.4.
 REQUEST_FILE:
  See section 1.2.5.
 CLEAR:
  See section 1.2.6.
 REQUEST_UPDATE:
  See section 1.2.7.
 KEEPALIVE:
  See section 1.2.8.
 ACCOUNT:
  See section 1.2.9.
 ITEM_EXAMINE (player only):
  See section 1.2.10.
 ITEM_APPLY (player only):
  See section 1.2.11.
 ITEM_MOVE (player only):
  See section 1.2.12.
 REPLY (player only):
  See section 1.2.13.
 PLAYER_CMD (player only):
  See section 1.2.14.
 ITEM_LOCK (player only):
  See section 1.2.15.
 ITEM_MARK (player only):
  See section 1.2.16.
 FIRE (player only):
  See section 1.2.17.
 QUICKSLOT (player only):
  See section 1.2.18.
 QUESTLIST (player only):
  See section 1.2.19.
 MOVE_PATH (player only):
  See section 1.2.20.
 ITEM_READY (player only):
  See section 1.2.21.
 TALK (player only):
  See section 1.2.22.
 MOVE (player only):
  See section 1.2.23.
 TARGET (player only):
  See section 1.2.24.

===============================================================================
= 1.2.1. Server command CONTROL                                               =
===============================================================================
 This command is used to control the server through remote means (no player
 login is necessary).
 
 The implementation SHOULD have some sort of security checks to enable only
 specific IPs to control the server (for example, 127.0.0.1 or user-configured
 list of IPs). However, security measures for this are beyond the scope of this
 document, and are implementation-specific.
 
 For control commands that involve a player, a player MUST be chosen by the
 implementation; for example, the first player, or the first player who's a
 server operator, or a user-configured player name. It is possible that no
 player will be chosen (if no player that meets the criteria is logged in, for
 example). This behaviour is however also implementation-specific.
 
 For control commands that do involve a player, and one has been successfully
 found (logged in), the packet payload is forwarded to the player's client as
 client command CONTROL (see section 1.3.18). This allows the client to react
 upon the control command involving the player.
 
 The packet must be constructed as thus, in the listed order:
  - app_name (string):
     The application name (optionally version as well) that is requesting to
     control the server. This SHOULD only be used for informational purposes in
     things such as server logs, and not as a means of denying specific actions
     depending on the application's name. MUST not be empty.
  - type (uint8):
     Type of the control command. You can see the possible options below, and
     the rest of the packet structure depends on this type.
     
 The following is a list of possible control commands, starting at an index of
 one. If the control command requires a player, and no suitable player has been
 found, the implementation MUST exit and not do anything with the data it
 received.

 UPDATE_MAP (player required):
  This command is used to inform the server that a map has been updated by an
  external source (such as an editor), and to request some player (chosen by
  the implementation) to be teleported to the map at specified X and Y
  coordinates.
  
  The implementation MUST reload the map from file prior to teleporting the
  player.
  
  The packet is then extended with the following data, in the listed order:
   - mappath (string):
     Absolute path to the map file, relative to the "maps" directory; for
     example, "/shattered_islands/world_0115", or "/hall_of_dms".
   - x (sint16):
     X coordinate.
   - y (sint16):
     Y coordinate.

===============================================================================
= 1.3. Client commands                                                        =
===============================================================================
 The following is a list of commands recognised by the client.

 These start at zero; thus, command type 0 equals that of the first command
 here.

 MAP:
  See section 1.3.1.
 DRAWINFO:
  See section 1.3.2.
 FILE_UPDATE:
  See section 1.3.3.
 ITEM:
  See section 1.3.4.
 SOUND:
  See section 1.3.5.
 TARGET:
  See section 1.3.6.
 ITEM_UPDATE:
  See section 1.3.7.
 ITEM_DELETE:
  See section 1.3.8.
 STATS:
  See section 1.3.9.
 IMAGE:
  See section 1.3.10.
 ANIM:
  See section 1.3.11.
 SKILL_READY:
  See section 1.3.12.
 PLAYER:
  See section 1.3.13.
 MAPSTATS:
  See section 1.3.14.
 SKILL_LIST:
  See section 1.3.15.
 VERSION:
  See section 1.3.16.
 SETUP:
  See section 1.3.17.
 CONTROL:
  See section 1.3.18.
 DATA:
  See section 1.3.19.
 CHARACTERS:
  See section 1.3.20.
 BOOK:
  See section 1.3.21.
 PARTY:
  See section 1.3.22.
 QUICKSLOT:
  See section 1.3.23.
 COMPRESSED:
  See section 1.3.24.
 REGION_MAP:
  See section 1.3.25.
 SOUND_AMBIENT:
  See section 1.3.26.
 INTERFACE:
  See section 1.3.27.
 NOTIFICATION:
  See section 1.3.28.