===============================================================================
= ADS-2, rev: 0.1: Atrinik Protocol Specification                             =
===============================================================================
 This document contains design specification for the Atrinik client<->server
 protocol. The following sections exist:

 1. Session
    1.2 Keepalive
 2. Server commands
    1.2.1  Server command CONTROL
    1.2.2  Server command ASK_FACE
    1.2.3  Server command SETUP
    1.2.4  Server command VERSION
    1.2.5  Server command REQUEST_FILE
    1.2.6  Server command CLEAR
    1.2.7  Server command REQUEST_UPDATE
    1.2.8  Server command KEEPALIVE
    1.2.9  Server command ACCOUNT
    1.2.10 Server command ITEM_EXAMINE
    1.2.11 Server command ITEM_APPLY
    1.2.12 Server command ITEM_MOVE
    1.2.13 Server command REPLY
    1.2.14 Server command PLAYER_CMD
    1.2.15 Server command ITEM_LOCK
    1.2.16 Server command ITEM_MARK
    1.2.17 Server command FIRE
    1.2.18 Server command QUICKSLOT
    1.2.19 Server command QUESTLIST
    1.2.20 Server command MOVE_PATH
    1.2.21 Server command ITEM_READY
    1.2.22 Server command TALK
    1.2.23 Server command MOVE
    1.2.24 Server command TARGET
 3. Client commands
    1.3.1  Client command MAP
    1.3.2  Client command DRAWINFO
    1.3.3  Client command FILE_UPDATE
    1.3.4  Client command ITEM
    1.3.5  Client command SOUND
    1.3.6  Client command TARGET
    1.3.7  Client command ITEM_UPDATE
    1.3.8  Client command ITEM_DELETE
    1.3.9  Client command STATS
    1.3.10 Client command IMAGE
    1.3.11 Client command ANIM
    1.3.12 Client command SKILL_READY
    1.3.13 Client command PLAYER
    1.3.14 Client command MAPSTATS
    1.3.15 Client command SKILL_LIST
    1.3.16 Client command VERSION
    1.3.17 Client command SETUP
    1.3.18 Client command CONTROL
    1.3.19 Client command DATA
    1.3.20 Client command CHARACTERS
    1.3.21 Client command BOOK
    1.3.22 Client command PARTY
    1.3.23 Client command QUICKSLOT
    1.3.24 Client command COMPRESSED
    1.3.25 Client command REGION_MAP
    1.3.26 Client command SOUND_AMBIENT
    1.3.27 Client command INTERFACE
    1.3.28 Client command NOTIFICATION
 4. Example logic

===============================================================================
= 1. Session                                                                  =
===============================================================================
 Atrinik uses a standard TCP/IP connection to establish a session. Once a
 session has been established, the client and the server are free to exchange
 data at will, in an asynchronous mode of data exchange. After this is done, it
 is recommended that the server and the client exchange version information,
 with the use of the version command (see section 1.2.4 and section 1.3.16).
 This allows both the client and the server to be aware of what commands the
 other side supports, and in what format, thus allowing backward compatibility.

 Currently, only IPv4 sessions are supported, but IPv6 support is planned but
 not yet implemented in any way whatsoever.

 The network order is MSB (Most Significant Byte), also known as big-endian.

 The implementation SHOULD use non-blocking sockets to receive and send data.
 Using threads for this is highly recommended.

 The implementation SHOULD disable Nagle's algorithm, as this algorithm is
 enabled by default but introduces artificial lag due to buffering data until
 some amount of data has been buffered, then flushing the buffer. This
 behaviour has no place in a real-time action RPG such as Atrinik, where player
 should get feedback to their actions as quickly as possible.

 The server implementation MUST use some sort of buffers for data to send and
 receive, in order to allow for cancellation/compression/prioritisation/etc.
 The recommended approach is to use FIFO queues. The client is free to choose
 whether to implement such behaviour.

===============================================================================
= 1.1. Packets                                                                =
===============================================================================
 Data packets are constructed in MSB (Most Significant Byte) order, also known
 as big-endian.

 Each packet starts with a 2-byte header, which is an integer that contains
 information about the length of its payload. In the case of the client, this
 should always be sent to the server as unsigned (uint16).

 The server MUST implement the following additional behaviour for the header:
 in the case that the payload length is shorter than 0x8000, the length MUST
 be encoded as uint16. Otherwise, the length MUST be encoded as uint24, with
 0x800000 added. Thus, the client MUST implement behaviour to handle this (for
 example, if the first byte's bit 7 is 0, the header is uint16, otherwise it's
 uint24 minus 0x800000).

 The payload should always contain the command type as 8-bit integer, followed
 by any data, in any format whatsoever, but still binary. See section 1.2. for
 the available server commands organized by command type, and section 1.3. for
 the available client commands.

 Left shifting is done to convert any integers of size more than 1 byte. Signed
 integers are converted to signed data type.

 The following packet data types are recognised:
  - uint8
  - sint8
  - uint16
  - sint16
  - uint32
  - sint32
  - uint64
  - sint64
  - string:
     UTF-8 string, terminated by a NUL character.

===============================================================================
= 1.2. Keepalive                                                              =
===============================================================================
 Once a session has been established, the client MUST send keepalive (command
 explained in section 3.8) packets to the server, at an interval of no more
 than one packet per minute.

 If the server does not receive a keepalive packet from the client for a period
 longer than 10 minutes, it MUST, for all intents and purposes, consider the
 session as dead and drop the connection.

===============================================================================
= 1.2. Server commands                                                        =
===============================================================================
 The following is a list of commands recognised by the server.

 These start at zero; thus, command type 0 equals that of the first command
 here.

 CONTROL:
  See section 1.2.1.
 ASK_FACE:
  See section 1.2.2.
 SETUP:
  See section 1.2.3.
 VERSION:
  See section 1.2.4.
 REQUEST_FILE:
  See section 1.2.5.
 CLEAR:
  See section 1.2.6.
 REQUEST_UPDATE:
  See section 1.2.7.
 KEEPALIVE:
  See section 1.2.8.
 ACCOUNT:
  See section 1.2.9.
 ITEM_EXAMINE (player only):
  See section 1.2.10.
 ITEM_APPLY (player only):
  See section 1.2.11.
 ITEM_MOVE (player only):
  See section 1.2.12.
 REPLY (player only):
  See section 1.2.13.
 PLAYER_CMD (player only):
  See section 1.2.14.
 ITEM_LOCK (player only):
  See section 1.2.15.
 ITEM_MARK (player only):
  See section 1.2.16.
 FIRE (player only):
  See section 1.2.17.
 QUICKSLOT (player only):
  See section 1.2.18.
 QUESTLIST (player only):
  See section 1.2.19.
 MOVE_PATH (player only):
  See section 1.2.20.
 ITEM_READY (player only):
  See section 1.2.21.
 TALK (player only):
  See section 1.2.22.
 MOVE (player only):
  See section 1.2.23.
 TARGET (player only):
  See section 1.2.24.

===============================================================================
= 1.2.1. Server command CONTROL                                               =
===============================================================================
 This command is used to control the server through remote means (no player
 login is necessary).

 The implementation SHOULD have some sort of security checks to enable only
 specific IPs to control the server (for example, 127.0.0.1 or user-configured
 list of IPs). However, security measures for this are beyond the scope of this
 document, and are implementation-specific.

 The packet must be constructed as thus, in the listed order:
  - app_name (string):
     The application name (optionally version as well) that is requesting to
     control the server. This SHOULD only be used for informational purposes in
     things such as server logs, and not as a means of denying specific actions
     depending on the application's name. MUST not be empty.
  - type (uint8):
     Type of the control command. This defines what kind of control packet this
     is (whether it concerns a map, or a player, for example).
  - subtype (uint8):
     Sub-type of the control command; for example, teleporting a player, or
     resetting a map.

 The following is a list of possible control command types, starting at an
 index of one.

 MAP:
  This command is used to control maps loaded by the server. The value of
  subtype defines what to do with the map file.

  The packet is extended with the following data, in the listed order:
   - mappath (string):
      Absolute path to the map file, relative to the "maps" directory; for
      example, "/shattered_islands/world_0115", or "/hall_of_dms". If empty, or
      the map file has not been loaded before, the implementation MUST ignore
      the command and discard the rest of any data it may have received
      associated with this command.

  The following is a list of possible sub-types for this command type, starting
  at an index of one.

  RESET:
   Used to request the reset of the specified map (due to for example, an
   update to the map file by an external source).
 PLAYER:
  This command is used to control players that are currently logged in.

  The packet is extended with the following data, in the listed order:
   - playername (string):
      Player name to control; can be empty.

  If the received player name is empty, a player MUST be chosen by the
  implementation; for example, the first player, or the first player who's a
  server operator, or a user-configured player name. It is possible that no
  player will be chosen (if no player that meets the criteria is logged in, for
  example). This behaviour is however also implementation-specific.

  If no suitable player has been found, the implementation MUST ignore the
  command and discard the rest of any data it may have received associated with
  this command.

  If a player has been successfully found (logged in), the entire packet
  payload MUST be forwarded to the player's client as client command CONTROL
  (see section 1.3.18).

  The following is a list of possible sub-types for this command type, starting
  at an index of one.

  TELEPORT:
   This command is used to teleport the previously specified player to the
   specified map, at the specified X/Y coordinates.

   The packet is extended with the following data, in the listed order:
    - mappath (string):
       Absolute path to the map file, relative to the "maps" directory; for
       example, "/shattered_islands/world_0115", or "/hall_of_dms".
    - x (sint16):
       X coordinate.
    - y (sint16):
       Y coordinate.

 MAP_RESET:
  This command is used to request the reset of the specified map (due to for
  example, an update to the map file by an external source).

  The packet is then extended with the following data, in the listed order:
 PLAYER_TELEPORT:

  The packet is then extended with the following data, in the listed order:
   - playername (string):
     Player to teleport; if empty, some player will be chosen by the
     implementation.

===============================================================================
= 1.3. Client commands                                                        =
===============================================================================
 The following is a list of commands recognised by the client.

 These start at zero; thus, command type 0 equals that of the first command
 here.

 MAP:
  See section 1.3.1.
 DRAWINFO:
  See section 1.3.2.
 FILE_UPDATE:
  See section 1.3.3.
 ITEM:
  See section 1.3.4.
 SOUND:
  See section 1.3.5.
 TARGET:
  See section 1.3.6.
 ITEM_UPDATE:
  See section 1.3.7.
 ITEM_DELETE:
  See section 1.3.8.
 STATS:
  See section 1.3.9.
 IMAGE:
  See section 1.3.10.
 ANIM:
  See section 1.3.11.
 SKILL_READY:
  See section 1.3.12.
 PLAYER:
  See section 1.3.13.
 MAPSTATS:
  See section 1.3.14.
 SKILL_LIST:
  See section 1.3.15.
 VERSION:
  See section 1.3.16.
 SETUP:
  See section 1.3.17.
 CONTROL:
  See section 1.3.18.
 DATA:
  See section 1.3.19.
 CHARACTERS:
  See section 1.3.20.
 BOOK:
  See section 1.3.21.
 PARTY:
  See section 1.3.22.
 QUICKSLOT:
  See section 1.3.23.
 COMPRESSED:
  See section 1.3.24.
 REGION_MAP:
  See section 1.3.25.
 SOUND_AMBIENT:
  See section 1.3.26.
 INTERFACE:
  See section 1.3.27.
 NOTIFICATION:
  See section 1.3.28.
